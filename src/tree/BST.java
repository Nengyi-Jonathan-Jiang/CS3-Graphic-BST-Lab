package tree;

import util.ANSICode;

import java.util.*;

// Hehe this is literally Java TreeSet but with BSTs and exposed TreeNodes
public class BST<T extends Comparable<T>> implements Set<T> {
	protected BSTNode<T> root = null;

	/**
	 * @param value The value to search for
	 * @return whether the value exists in the tree
	 * @throws ClassCastException when value is not comparable
	 */
	public boolean contains (Object value) {
		if (!(value instanceof Comparable<?>)) throw new ClassCastException();
		return find((T) value) != null;
	}

	/**
	 * @param values The values to search for
	 * @return whether all the values exists in the tree
	 * @throws ClassCastException when any of the values is not comparable
	 */
	public boolean containsAll (Collection<?> values) {
		return values.stream().allMatch(this::contains);
	}

	/**
	 * @param value The value to insert into the tree
	 * @return whether the tree changed as a result of this call
	 */
	public boolean add (T value) {
		if (root == null) {
			root = new BSTNode<>(value);
			return true;
		} else return add(root, value);
	}

	/**
	 * @param values the values to be inserted into the tree.
	 * @return whether the collection was changed as a result of this operation
	 */
	public boolean addAll (Collection<? extends T> values) {
		return values.stream().map(this::add).toList().contains(true);
	}

	/**
	 * @param parent The root node to insert under
	 * @param value  The value to insert into the tree
	 * @return whether the tree changed as a result of this call
	 */
	protected boolean add (BSTNode<T> parent, T value) {
		int compare = value.compareTo(parent.getValue());

		if (compare < 0) {
			if (parent.hasLeftChild())
				add(parent.getLeftChild(), value);
			else parent.insertLeft(value);
		} else {
			if (parent.hasRightChild())
				add(parent.getRightChild(), value);
			else parent.insertRight(value);
		}
		//else return false; // else: Node already in tree, do nothing :)

		return true;
	}

	/**
	 * @param value the value to erase from the tree
	 * @return whether a value was removed as a result of this call
	 * @throws ClassCastException when value is not comparable
	 */
	@Override
	public boolean remove (Object value) {
		// <rant>
		// I hate how Java generics work
		// Why can't T be treated like a real class name?
		// Look at C#, or even C++! That is the right way to do it, to build it into the language as a core feature
		// Instead, Java compiles it all down to Object (type erasure) and adds casts on parameters and return types
		// In the name of "Backwards Compatibility" so old JVMs can still run the generated bytecode
		// EXCEPT THEY CAN'T!
		// ERROR: "THIS FILE WAS COMPILED WITH A NEWER VERSION OF JAVA!"
		// BACKWARDS COMPATIBILITY MY ASS! (If you can curse in class, I can curse here. Also, please don't kill me)
		// I can't even check that value is of type T! (I have to take it as Object because Collection dictates so)
		// I can only ensure it is a Comparable (which is just sufficient to prevent breaking the code)
		// *Breaths heavily*
		// </rant>

		if (!(value instanceof Comparable<?>)) throw new ClassCastException(); // See what I have to resort to? Yuck.

		BSTNode<T> target = find((T) value);
		if (target == null) return false;

		// Delete root
		if (target == root && target.isLeaf()) root = null;

		else if (target.getDegree() == 2) {  // Find inorder successor n and swap, then erase n
			BSTNode<T> node = target.getRightChild();
			while (node.hasLeftChild()) node = node.getLeftChild();

			BSTNode.swapContents(target, node);
			deleteSimple(node);
		} else {  // Deg = 0 or 1, put child node (if exists) into the place that the node previously occupied
			deleteSimple(target);
		}
		return true;
	}

	protected void deleteSimple (BSTNode<T> target) {
		var node = target.hasLeftChild() ? target.getLeftChild() : target.hasRightChild() ? target.getRightChild() : null;
		switch (target.getChildType()) {
			case LEFT -> target.getParent().setLeftChild(node);
			case RIGHT -> target.getParent().setRightChild(node);
			case ROOT -> root = target.getLeftChild().makeRoot();
		}
	}

	/**
	 * @param values The values to remove from the tree
	 * @return whether the collection was changed as a result of this operation
	 */
	public boolean removeAll (Collection<?> values) {
		return values.stream().map(this::remove).toList().contains(true);
	}

	/**
	 * @param c A collection of values to intersect with this tree
	 * @return A new bst.BST containing the elements common to this tree and the given values
	 */
	public BST<T> intersection (Collection<?> c){
		BST<T> res = new BST<>();
		c.stream()
			.filter(this::contains) // Filter out the elements that are not in this tree
			.map(i -> (T) i)    // Cast the elements to type T (to Comparable, after erasure)
			.map(this::find)    // Get the actual
			.map(BSTNode::getValue)
			.forEach(res::add);
		return res;
	}

	/**
	 * @param c The values to keep in the tree
	 * @return A new bst.BST containing the elements common to this tree and the given values
	 */
	@Override
	public boolean retainAll (Collection<?> c) {
		var temp = intersection(c);
		boolean res = !new ArrayList<>(this).equals(new ArrayList<>(temp)); // This operation should be O(N) I think
		root = temp.getRoot();  // Hehe just copy the temp tree to this tree
		return res;
	}

	/**
	 * Removes all items from the tree
	 */
	@Override
	public void clear () {
		// Well, that was fast...
		// I would never have thought I would ever say this, but thank god for GC
		root = null;
	}

	/**
	 * @param value the value to search for
	 * @return the node with that value, or null if the value is not in the tree
	 */
	protected BSTNode<T> find (T value) {
		return find(root, value);
	}

	/**
	 * @param node  The root node to search from
	 * @param value The value to search for
	 * @return the {@link BSTNode} with that value, or null if the value is not in the tree
	 */
	protected BSTNode<T> find (BSTNode<T> node, T value) {
		if (node == null) return null;

		int compare = value.compareTo(node.getValue());

		if (compare < 0)
			return find(node.getLeftChild(), value);
		if (compare > 0)
			return find(node.getRightChild(), value);
		return node;
	}

	@Override
	public int size () {
		return countNodes(root);
	}

	protected int countNodes (BSTNode<T> node) {
		return node == null ? 0 : 1 + countNodes(node.getLeftChild()) + countNodes(node.getRightChild());
	}

	/**
	 * @return whether the tree is empty
	 */
	public boolean isEmpty () {
		return root == null;
	}

	@Override
	public Iterator<T> iterator () {
		return root == null ? Collections.emptyIterator() : new Iterator<>() {
			private final Stack<BSTNode<T>> nodes = new Stack<>();
			private BSTNode<T> curr = root;

			@Override
			public boolean hasNext () {
				while (curr != null) {
					nodes.push(curr);
					curr = curr.getLeftChild();
				}
				return !nodes.isEmpty();
			}

			public T next () {
				var res = nodes.pop();
				curr = res.getRightChild();
				return res.getValue();
			}
		};
	}

	public Object[] toArray () {
		// IntelliJ suggests that I replace stream().toArray() with this.toArray()
		// Wow, that would definitely work!
		// Yeah, I wanna call toArray() in the toArray() method!
		// No.
		// Just no.

		//noinspection SimplifyStreamApiCallChains
		return stream().toArray();
	}

	public <U> U[] toArray (U[] a) {
		// IDK how hacky this is, I never understood the purpose of this method overload
		return (U[]) toArray();
	}

	@Override
	public String toString () {
		return root == null ? "bst.BST{}" : "bst.BST" + root;
	}

	/**
	 * @return The height of the tree. This is the number of edges from the root to the deepest leaf
	 */
	public int getHeight () {
		return root == null ? -1 : root.getHeight();
	}

	/**
	 * @return The root node of the tree. If the tree is empty, this is null
	 */
	public BSTNode<T> getRoot () {
		return root;
	}

	/**
	 * @return the number of leaves in the tree
	 */
	public int countLeaves () {
		return countLeaves(root);
	}

	/**
	 * @param node the root of the tree to search
	 * @return the number of leaves in the tree
	 */
	protected int countLeaves (BSTNode<T> node) {
		return node == null ? 0 : node.isLeaf() ? 1 : countLeaves(node.getLeftChild()) + countLeaves(node.getRightChild());
	}

	/**
	 * @return The number of levels in the tree.
	 */
	public int countLevels () {
		return getHeight() + 1;
	}

	public int getWidth () {
		return Arrays.stream(getLevelWidths()).reduce(0, Math::max);
	}

	public int getDiameter () {
		return root == null ? 0 : 3 + (root.hasLeftChild() ? root.getLeftChild().getHeight() : 0) + (root.hasRightChild() ? root.getRightChild().getHeight() : 0);
	}

	public boolean isFullTree () {
		return root == null || isFull(root);
	}

	protected boolean isFull (BSTNode<T> node) {
		return node.getDegree() == 0 || node.getDegree() == 2 && isFull(node.getLeftChild()) && isFull(node.getRightChild());
	}

	public T getLargest () {
		return root == null ? null : getLargest(root);
	}

	protected T getLargest (BSTNode<T> node) {
		return node.hasRightChild() ? getLargest(node.getRightChild()) : node.getValue();
	}

	public T getSmallest () {
		return root == null ? null : getSmallest(root);
	}

	protected T getSmallest (BSTNode<T> node) {
		return node.hasLeftChild() ? getSmallest(node.getLeftChild()) : node.getValue();
	}

	public T[][] getLevels () {
		if (root == null) return (T[][]) new Comparable[][] { };

		final int levels = countLevels();
		final T[][] res = (T[][]) new Comparable[levels][];
		final BSTNode<T>[][] nodes = new BSTNode[levels][];
		nodes[0] = new BSTNode[] { root };
		res[0] = (T[]) new Comparable[] { root.getValue() };

		for (int h = 1; h < levels; h++) {
			int size = 1 << h;
			nodes[h] = new BSTNode[size];
			res[h] = (T[]) new Comparable[size];
			for (int i = 0; i * 2 < size; i++) {
				var n = nodes[h - 1][i];
				if (n != null) {
					var l = nodes[h][i * 2] = n.getLeftChild();
					var r = nodes[h][i * 2 + 1] = n.getRightChild();
					if (l != null) res[h][i * 2] = l.getValue();
					if (r != null) res[h][i * 2 + 1] = r.getValue();
				}
			}
		}
		return res;
	}

	public int[] getLevelWidths () {
		// Java FP is nice, but verbose
		// Whatever, I will use it because I am lazy
		return Arrays.stream(getLevels()).mapToInt(i -> (int) Arrays.stream(i).filter(Objects::nonNull).count()).toArray();
	}


	public void print() {
		if (isEmpty()) {
			System.out.println("Empty Tree");
			return;
		}

		final int height = countLevels();
		final BSTNode<T>[][] levels = new BSTNode[height][];
		levels[0] = new BSTNode[] { root };
		for (int h = 1; h < height; h++) {
			int size = 1 << h;
			levels[h] = new BSTNode[size];
			for (int i = 0; i * 2 < size; i++) {
				var n = levels[h - 1][i];
				if (n != null) {
					levels[h][i * 2] = n.getLeftChild();
					levels[h][i * 2 + 1] = n.getRightChild();
				}
			}
		}

		final int[][] widths = new int[height][];
		for (int r = height - 1; r >= 0; r--) {
			widths[r] = new int[levels[r].length];

			for (int i = 0; i < levels[r].length; i++) {
				if (levels[r][i] == null) {
					if (levels[r][i ^ 1] != null) {
						for (int rr = r, ii = i; rr < height; rr++, ii *= 2) {
							widths[rr][ii] = 4;
						}
					}
				} else {
					int w = levels[r][i].getValue().toString().length() + 3;
					int width = r == height - 1
							? w
							: Math.max(w, widths[r + 1][i * 2] + widths[r + 1][i * 2 + 1]);
					widths[r][i] = width;

					if (!levels[r][i].hasRightChild() && !levels[r][i].hasLeftChild()) {
						for (int rr = r, ii = i; rr < height; rr++, ii *= 2) {
							widths[rr][ii] = width;
						}
					}
				}
			}
		}

		for (int r = 0; r < height; r++) {
			for (int i = 0; i < levels[r].length; i++) {
				var node = levels[r][i];
				int w = widths[r][i];

				if (w == 0) continue;

				if (node == null) {
					System.out.print(ANSICode.WHITE + "[");
					System.out.print("-".repeat(w - 3));
					System.out.print("] " + ANSICode.CLEAR);
				} else {
					_printNode(node, w);
				}
			}
			System.out.println();
		}
	}
	protected void _printNode(BSTNode<T> node, int targetWidth){
		System.out.print("[" + ANSICode.BOLD);

		String s = node.getValue().toString();
		int length = s.length();
		int lp = (targetWidth - 3 - length) / 2;
		int rp = targetWidth - 3 - lp - length;
		System.out.print(" ".repeat(lp) + s + " ".repeat(rp) + ANSICode.CLEAR + "] ");
	}
}